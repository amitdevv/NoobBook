# Auto-deploy NoobBook to AWS EC2
# Triggers on push to develop branch.
# SSHs into EC2, pulls latest code, runs migrations, rebuilds app containers.
# Supabase containers are NOT touched — only backend + frontend rebuild.

name: Deploy to AWS EC2

on:
  push:
    branches:
      - develop

  # Allow manual trigger from GitHub UI
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    # Only run on amitdevv's fork — skip on parent repo (TeacherOp) and other forks
    if: github.repository == 'amitdevv/NoobBook'

    steps:
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script_stop: true
          timeout: 600s
          script: |
            set -e

            echo "=== Navigating to project ==="
            cd ~/NoobBook

            echo "=== Pulling latest code ==="
            git fetch origin develop
            git checkout develop
            git pull origin develop

            # Verify pull succeeded by checking HEAD matches remote
            LOCAL_SHA=$(git rev-parse HEAD)
            REMOTE_SHA=$(git rev-parse origin/develop)
            if [ "$LOCAL_SHA" != "$REMOTE_SHA" ]; then
              echo "FAIL: git pull incomplete (local=$LOCAL_SHA remote=$REMOTE_SHA)"
              exit 1
            fi
            echo "Code verified at $LOCAL_SHA"

            echo "=== Running migrations ==="
            # Runs init.sql (if fresh DB) + applies any new migration files.
            # Safe to run every deploy — idempotent (skips already-applied migrations).
            docker compose up migrate --build

            echo "=== Rebuilding app containers ==="
            # Only rebuilds backend + frontend. Supabase containers stay untouched.
            docker compose up -d --build --no-deps backend frontend

            echo "=== Waiting for backend to be ready ==="
            # Poll backend health instead of fixed sleep
            for i in $(seq 1 30); do
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:5001/api/v1/projects 2>/dev/null)
              if echo "$HTTP_CODE" | grep -qE "^(200|401)$"; then
                echo "Backend ready after ${i}s (HTTP $HTTP_CODE)"
                break
              fi
              if [ "$i" -eq 30 ]; then
                echo "FAIL: backend not responding after 30s (got $HTTP_CODE)"
                exit 1
              fi
              sleep 1
            done

            echo "=== Health check ==="
            # Verify both containers are running
            docker ps --filter "name=noobbook-backend" --format "{{.Names}}" | grep -q "noobbook-backend" || { echo "FAIL: backend not running"; exit 1; }
            docker ps --filter "name=noobbook-frontend" --format "{{.Names}}" | grep -q "noobbook-frontend" || { echo "FAIL: frontend not running"; exit 1; }

            echo "=== Cleaning up old images ==="
            docker image prune -f

            echo "=== Deploy complete ==="
